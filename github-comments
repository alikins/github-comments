#!/usr/bin/python

# show github pull request comments in a lint like format
#
# ala, pep8, jslint, etc, except for code review comments
#
# potentially useful to use with syntastic/flymake/etc
#
# Thoughts:
#   - it would be nice if this was a minimal dep one file script
#   - it would be nice if this could DWIM and find the approriate
#     pull requests automatically
#   - initial use case is "I have a local branch, that I've pushed
#     to github, and isssued a pull request. I would like to see
#     the per line code review comments for that pull request"
#   - may eventually also support showing comments for arbitrary
#     pull requests. for example, if you are reviewing a pull
#     request, you could see the comments other have made
#   - unsure what to do with the primary comments view...
#     - anything that references a file could get it as a per file
#       comment
#     - at least tools like vim makeprg/errorformat/quicklist/make
#       can deal with per project/branch config
#   - it is a little tricky figuring out what the right pull request
#     is, especially if local/remote ref names dont match, and there is
#     no tracking branch. Should be able to find it by tracking donw
#     the right sha's though

from hashlib import md5
import json
# we could ditch the git subprocess probably
import subprocess
import re
import sys

# for parsing html into plain txt
from BeautifulSoup import BeautifulSoup
# for parsing markdown into html, since the comments use it
import markdown
# for http, though curl or even urllib will be okay
# if we stick to a single file util concept
import requests

import pprint
pp = pprint.pprint

# clearly not the most rebust arg handling yet
#try:
#    user = sys.argv[1]
#    repo = sys.argv[2]
#    pull_request = sys.argv[3]
#except Exception:
#    print "usage: github-comments repo_name pr_number"
#    raise


# I love regular expressions as much as the next guy, but
# sometimes I just dont want to use them
def find_github_repo():
    process = subprocess.Popen(['/usr/bin/git', 'config', '-l'], stdout=subprocess.PIPE)
    git_config = process.communicate()[0]
    config_lines = git_config.splitlines()
    for config_line in config_lines:
        if not config_line.startswith('remote.'):
            continue
        key, value = config_line.split('=', 1)
        if not key.endswith('.url'):
            continue
        repo_url = value
        repo_url_parts = repo_url.rsplit('/', 1)
        repo_name_dot_git = repo_url_parts[-1]
        if repo_name_dot_git.endswith('.git'):
            repo_name = repo_name_dot_git[:-4]
        else:
            repo_name = repo_name_dot_git
        owner_name = repo_url_parts[-2].split(':', 1)[1]
        return repo_name, owner_name

def get_branch_ref():
    # we could just read and parse .git/HEAD
    # needs to follow through to get upstream branch name
    # see "remote-ref" aliase in my gitconfig for example
    process = subprocess.Popen(['/usr/bin/git', 'rev-parse', '--abbrev-ref', 'HEAD'], stdout=subprocess.PIPE)
    this_branch = process.communicate()[0]
    return this_branch.strip()

repo_name, repo_owner = find_github_repo()

ref_name = get_branch_ref()

# need repo_owner and repo_name to ask for the pull requests
r = requests.get("https://api.github.com/repos/%s/%s/pulls?open" % (repo_owner, repo_name))
prs = json.loads(r.text or r.content)
pull_request_number = None
for pr in prs:
    pp(pr['head'])
    # find the pull request that has match ref name
    if pr['head']['ref'] == u'%s' % ref_name:
        pull_request_number = pr['number']

# see list of pull commits, including info about the ref of the branch
# it was created for.
# https://api.github.com/repos/candlepin/subscription-manager/pulls?open

# set errorformat='%f:%l:%m,%E%f:%l:%m,%-Z%^%$


# from from https://gist.github.com/gasman/856894
# bundle here for convience
def gfm(text):
    # Extract pre blocks.
    extractions = {}
    def pre_extraction_callback(matchobj):
        digest = md5(matchobj.group(0)).hexdigest()
        extractions[digest] = matchobj.group(0)
        return "{gfm-extraction-%s}" % digest
    pattern = re.compile(r'<pre>.*?</pre>', re.MULTILINE | re.DOTALL)
    text = re.sub(pattern, pre_extraction_callback, text)

    # Prevent foo_bar_baz from ending up with an italic word in the middle.
    def italic_callback(matchobj):
        s = matchobj.group(0)
        if list(s).count('_') >= 2:
            return s.replace('_', '\_')
        return s
    pattern = re.compile(r'^(?! {4}|\t)\w+(?<!_)_\w+_\w[\w_]*', re.MULTILINE | re.UNICODE)
    text = re.sub(pattern, italic_callback, text)

    # In very clear cases, let newlines become <br /> tags.
    def newline_callback(matchobj):
        if len(matchobj.group(1)) == 1:
            return matchobj.group(0).rstrip() + '  \n'
        else:
            return matchobj.group(0)
    pattern = re.compile(r'^[\w\<][^\n]*(\n+)', re.MULTILINE | re.UNICODE)
    text = re.sub(pattern, newline_callback, text)

    # Insert pre block extractions.
    def pre_insert_callback(matchobj):
        return '\n\n' + extractions[matchobj.group(1)]
    text = re.sub(r'{gfm-extraction-([0-9a-f]{32})\}', pre_insert_callback, text)

    return text


if pull_request_number is None:
    print "no pull requests found"
    sys.exit()

# github pull request comments api
r = requests.get("https://api.github.com/repos/%s/%s/pulls/%s/comments" % (repo_owner, repo_name, pull_request_number))
comments = json.loads(r.text or r.content)

for comment in comments:
    body_text_gfm = comment['body']
    body_text_md = gfm(body_text_gfm)
    body_text_html = markdown.markdown(body_text_md)
    body_text_lines = (BeautifulSoup(body_text_html).findAll(text=True))

    body_text = "\n".join(body_text_lines)

    print "%s:%s:%s: %s" % (comment['path'], comment['position'], comment['user']['login'],
                            body_text)


